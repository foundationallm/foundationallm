using FoundationaLLM.Common.Authentication;
using FoundationaLLM.Common.Exceptions;
using FoundationaLLM.Common.Interfaces;
using FoundationaLLM.Common.Models.Vectorization;
using FoundationaLLM.Common.Settings;
using FoundationaLLM.SemanticKernel.Core.Models.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Connectors.AzureAISearch;
using Microsoft.SemanticKernel.Memory;
using System.ComponentModel;
using System.Text.Json;
using Microsoft.SemanticKernel.Connectors.Postgres;

#pragma warning disable SKEXP0001, SKEXP0020

namespace FoundationaLLM.SemanticKernel.Core.Services.Indexing
{
    /// <summary>
    /// Provides vector embedding indexing based on PostgreSQL.
    /// </summary>
    public class PostgresIndexingService : IIndexingService
    {
        private readonly PostgresIndexingServiceSettings _settings;
        private readonly ILogger<PostgresIndexingService> _logger;
        private readonly PostgresMemoryStore _memoryStore;

        /// <summary>
        /// Creates a new <see cref="PostgresIndexingService"/> instance.
        /// </summary>
        /// <param name="options">The <see cref="IOptions{TOptions}"/> providing configuration settings.</param>
        /// <param name="logger">The <see cref="ILogger"/> used for logging.</param>
        public PostgresIndexingService(
            IOptions<PostgresIndexingServiceSettings> options,
            ILogger<PostgresIndexingService> logger)
        {
            _settings = options.Value;
            _logger = logger;
            _memoryStore = CreateMemoryStore();
        }

        /// <inheritdoc/>
        public async Task<List<string>> IndexEmbeddingsAsync(EmbeddedContent embeddedContent, string indexName)
        {
            if (!await _memoryStore.DoesCollectionExistAsync(indexName, default).ConfigureAwait(false))
            {
                await _memoryStore.CreateCollectionAsync(indexName, default).ConfigureAwait(false);
            }

            var indexIds = new List<string>();
            var memoryRecords = embeddedContent.ContentParts.Select(cp => MemoryRecord.LocalRecord(
                cp.Id,
                cp.Content,
                "Generated by FoundationaLLM.",
                cp.Embedding.Vector,
                JsonSerializer.Serialize(embeddedContent.ContentId),
                embeddedContent.ContentId.UniqueId,
                DateTimeOffset.UtcNow)).ToList();

            await foreach (var id in _memoryStore.UpsertBatchAsync(
                indexName, memoryRecords))
            {
                indexIds.Add(id);
            }

            return indexIds;
        }

        private void ValidateSettings(string? connectionString, string? vectorSize)
        {
            if (string.IsNullOrWhiteSpace(connectionString))
            {
                _logger.LogCritical("The PostgreSQL connection string is invalid.");
                throw new ConfigurationValueException("The PostgreSQL connection string is invalid.");
            }

            if (string.IsNullOrWhiteSpace(vectorSize) || !int.TryParse(vectorSize, out _))
            {
                _logger.LogCritical("The PostgreSQL vector size is invalid.");
                throw new ConfigurationValueException("The PostgreSQL vector size is invalid.");
            }
        }

        private PostgresMemoryStore CreateMemoryStore()
        {
            ValidateSettings(_settings.ConnectionString, _settings.VectorSize);
            _ = int.TryParse(_settings.VectorSize, out var vectorSize);
            return !string.IsNullOrWhiteSpace(_settings.Schema) ?
                new PostgresMemoryStore(_settings.ConnectionString, vectorSize, _settings.Schema) :
                new PostgresMemoryStore(_settings.ConnectionString, vectorSize);
        }
    }
}
